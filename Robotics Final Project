import rclpy
import math
from rclpy.node import Node

from nav_msgs.msg import Odometry
from geometry_msgs.msg import Twist

	def __init__(self, xmin, xmax, ymin, ymax, res):
		print('Creating Map')
		self.xmin = xmin
		self.xmax = xmax
		self.ymin = ymin
		self.ymax = ymax
		self.res = res
		self.W = math.ceil((xmax-xmin)/res)
		self.H = math.ceil((ymax-ymin)/res)
		self.map = np.full((self.H, self.W), 100, dtype=np.uint8)
		#self.map[10,15] = 255
		#cv2.imshow("map", self.map)
		#cv2.waitKey(50)
	
	def map2world(v, u):
		x = self.res*(v+0.5)+self.xmin
		y = -self.res*(u+0.5)+self.ymax
		return x, y
	
	def world2map(x, y):
		v = np.floor((x-self.xmin)/self.res).astype(int)
		u = np.floor((self.ymax-y)/self.res).astype(int)
		return v, u

	def insert_obstacle(self, v, u):c
		self.map[u, v] = 0
		
	def show_map(self):
		cv2.imshow("map", self.map)
		cv2.waitKey(50)

class hw10Controller(Node):
	def __init__(self):
		print('starting node initialization...')
		super().__init__('myfirstosnode')
		
		self.timer_period = 0.1
		self.b = 0.1
		self.x = 0
		self.y = 0
		self.yaw = 0 
		
		self.xd = 4.0 #Kyle
		self.yd = 6.0 #Ludwig
		
		self.kx = 0.1
		self.ky = 0.1
		
		self.cmd_publisher = self.create_publisher(Twist, '/cmd_vel', 0)
		self.subscription = self.create_subscription(Odometry, '/odom', self.odom_callback, 0)
		self.control_timer = self.create_timer(self.timer_period, self.control_callback)
		
		print('end node initialization')
		
	def odom_callback(self, msg):
		self.x = msg.pose.pose.position.x
		self.y = msg.pose.pose.position.y
		self.yaw = math.atan2(2.0*(msg.pose.pose.orientation.w * msg.pose.pose.orientation.z + msg.pose.pose.orientation.x * msg.pose.pose.orientation.y), 1.0-2.0*(msg.pose.pose.orientation.y * msg.pose.pose.orientation.y + msg.pose.pose.orientation.z * msg.pose.pose.orientation.z));
		
	def control_callback(self):
		self.x
		self.y
		self.yaw
		ex = self.xd - self.x
		ey = self.yd - self.y
		
		u1 = self.kx * ex
		u2 = self.ky * ey
			
		v = math.cos(self.yaw)*u1 + math.sin(self.yaw)*u2
		
		omega = -math.sin(self.yaw)*u1/self.b + math.cos(self.yaw)*u2/self.b
		
		twist_msg = Twist()
		twist_msg.linear.x = v
		twist_msg.angular.z = omega
		self.cmd_publisher.publish(twist_msg)
		
		print(self.x, self.y, self.yaw)
		


def main(args=None):
	rclpy.init(args=args)
	hw10_controller = hw10Controller()
	
	rclpy.spin(hw10_controller)
	
	hw10_controller.destroy_node()
	rclpy.shutdown()
	
if __name__ == '__main__':
	main() 


