import rclpy
import math
from rclpy.node import Node

from nav_msgs.msg import Odometry
from geometry_msgs.msg import Twist

	def __init__(self, xmin, xmax, ymin, ymax, res):
		print('Creating Map')
		self.xmin = xmin
		self.xmax = xmax
		self.ymin = ymin
		self.ymax = ymax
		self.res = res
		self.W = math.ceil((xmax-xmin)/res)
		self.H = math.ceil((ymax-ymin)/res)
		self.map = np.full((self.H, self.W), 100, dtype=np.uint8)
		#self.map[10,15] = 255
		#cv2.imshow("map", self.map)
		#cv2.waitKey(50)
	
	def map2world(v, u):
		x = self.res*(v+0.5)+self.xmin
		y = -self.res*(u+0.5)+self.ymax
		return x, y
	
	def world2map(x, y):
		v = np.floor((x-self.xmin)/self.res).astype(int)
		u = np.floor((self.ymax-y)/self.res).astype(int)
		return v, u

	def insert_obstacle(self, v, u):c
		self.map[u, v] = 0
		
	def show_map(self):
		cv2.imshow("map", self.map)
		cv2.waitKey(50)

class Project(Node):
	def __init__(self):
		print('starting node initialization...')
		super().__init__('myfirstosnode')
		
		self.map = MyMap(-10, 10, -10, 10, 0.05)
		
		self.timer_period = 0.1
		self.b = 0.1
		self.x = 0
		self.y = 0
		self.yaw = 0 
		
		self.xd = 4.0 #Kyle
		self.yd = 6.0 #Ludwig
		
		self.kx = 0.1
		self.ky = 0.1
		
		self.cmd_publisher = self.create_publisher(Twist, '/cmd_vel', 0)
		self.odom_subscription = self.create_subscription(Odometry, '/odom', self.odom_cbk, 0)
		self.scan_subscription = self.create_subscription(Laserscan, '/scan', self.scan_cbk, 0)
		self.control_timer = self.create_timer(self.timer_period, self.control_callback)
		
		print('end node initialization')
		
	def odom_cbk(self, msg):
		self.x = msg.pose.pose.position.x
		self.y = msg.pose.pose.position.y
		self.yaw = math.atan2(2.0*(msg.pose.pose.orientation.w * msg.pose.pose.orientation.z + msg.pose.pose.orientation.x * msg.pose.pose.orientation.y), 1.0-2.0*(msg.pose.pose.orientation.y * msg.pose.pose.orientation.y + msg.pose.pose.orientation.z * msg.pose.pose.orientation.z));
		
		
	def scan_cbk(self, msg):
		beta = msg.angle_incrememnt
		i = 0
		pRW = np.array([[self.x],
						[self.y]])
		RRW = np.array([[math.cos(self.yaw),-[math.sin(self.yaw)],
						[math.sin(self.yaw),[math.cos(self.yaw)]])
						
		for r in msg.ranges:
			if r<msg.range_max:
				theta_i = msg.angle_min + beta*i
				DR = np.array([[r*math.cos(theta_i)],
								[r*math.sin(theta_i)]])
				DW = RRW @	DR +rPW
				v, u = self.map.world2map(DW[0], DW[1])
				xm, y = self.map.world2map(DW[0],DW[1})
				self.map.insert_obstacle(v,u)
				print(v,u)
			i = i+1
		self.map.show_map()
			
			
	def control_callback(self):
		self.x
		self.y
		self.yaw
		ex = self.xd - self.x
		ey = self.yd - self.y
		
		u1 = self.kx * ex
		u2 = self.ky * ey
			
		v = math.cos(self.yaw)*u1 + math.sin(self.yaw)*u2
		
		omega = -math.sin(self.yaw)*u1/self.b + math.cos(self.yaw)*u2/self.b
		
		twist_msg = Twist()
		twist_msg.linear.x = v
		twist_msg.angular.z = omega
		self.cmd_publisher.publish(twist_msg)
		
		print(self.x, self.y, self.yaw)
		


def main(args=None):
	rclpy.init(args=args)
	Project = Project()
	
	rclpy.spin(Project)
	
	Project.destroy_node()
	rclpy.shutdown()
	
if __name__ == '__main__':
	main() 
